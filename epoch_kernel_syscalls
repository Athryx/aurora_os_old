TODO:
more descriptive error values

decide if vfs should go in kernel or not
if it does, can probably remove the info syscall and just use a proc like filesystem
also decide if files should be like unix or not (thinking no)

pledge like syscall

syscall to get groups that pid is part of

figure out how user permissions would work


syscall abi:
rax[0-31]: syscall number
rax[32-63]: syscall options
rbx: arg 1, return 1
rcx: not saved
rdx: arg 2, return 2
rbp: saved
rsp: saved
rsi: arg 3, return 3
rdi: arg 4, return 4
r8: arg 5, return 5
r9: arg 6, return 6
r10: not saved
r11: not saved
r12: arg 7, return 7
r13: arg 8, return 8
r14: arg 9, return 9
r15: arg 10, return 10

all args are saved if they are not used by a particular syscall to return a value

the kernel uses a similar abi to call message handlers
message handler abi:
rax: flags
rbx: sender pid
rcx: unused
rdx: domain
rbp: unused
rsp: unused
rsi: arg 1
rdi: arg 2
r8: arg 3
r9: arg 4
r10: unused
r11: unused
r12: arg 5
r13: arg 6
r14: arg 7
r15: arg 8


0: info


2: fn thread_new (rip: usize) -> (tid: usize, err: usize)
creates a new thread and returns its id
the thread function should not return, it should call thread_block with destroy in order to terminate itself

return value:
tid:
thread id
err:
0: success
1: error, could not create thread, value in .0 is garbage


3: fn thread_block (reason: usize, | nsec: usize | thread_id: usize)
blocks the calling thread with reason {reason}

reason:
0: yield, sets thread to running state and switches to another thread, if available
if no threads other than the idle thread are ready to run, the current thread will continue to run
1: destroy, switches to another thread and terminates the current thread
2: sleep, will sleep until {nsec} nanoseconds after boot
3: join, will block until thread with id {thread_id} terminates
any other number will do nothing


5: fn exit (code: usize)
terminates process with exit code {code}


6: fn futex_block (addr: usize)
bloocks the thread until woken by another thread via futex_unblock


7: fn futex_unblock (addr: usize, n: usize) -> usize
unblocks {n} threads waiting on addr and returns how many threads were unblocked
if addr is shared memory, this can also unblock threads in other processess that are waiting
on the same value, with a different virtual address


8: fn futex_move (addr_old: usize, addr_new: usize, n: usize) -> usize
moves {n} threads waiting on {addr_old} to start waiting on {addr_new} and returns how many threads were moved
it is not allowed to move a futex from an address within a shared memory zone to an address in a different shared
memory zone or into a non shared memory zone


9: set_proc_properties
// I don't know if this will stay


10: set_thread_properties


11: fn realloc (mem: usize, len: usize, at_addr: usize) -> (mem: usize, len: usize, err: usize)
allocates, rellocates, or frees memory pointed to by mem

if {mem} == 0:
	allocates {len} pages, returns pointer on succes or 0 on failure
	returns 0 if {len} == 0
if {mem} != 0 and {len} == 0:
	frees pages pointed to by {mem} and returns 1 on success or 0 on failure
if {mem} != 0 and {len} != 0:
	reallocates pages to have len {len} and returns pointer on success or 0 on failure
	if it fails, the original pages will still be allocated and must be freed later

if {at_addr} == 0, realloc will pick a suitable virtual address to allocae the memory at

if {at_addr} != 0, realloc will ensure that the allocated memory starts at address {at_addr}
if it cannot fit the memory at this address, it will fail
note: if realloc is allocing at a certain addrss, it may still fail even if there is enough space for {len} pages
this is because realloc may try to map more memory in the virtual address soace than specified by {len}
to ensure this doesn't happen, set the optsion realloc_exact

realloc will never allocate memory at virtual address 0

options:
bit 0 (read):
allows reading of memory

bit 1 (write):
allows writing to memory

bit 2 (exec):
allows executing instrcutions from memory

On x86, a page will always be readable, even if read bit is set to 0,
unless wrtie and exec are also set to 0, in which case realloc will just reserve
the virtual memory, and not actually allocate anything

read, write, and exec flags only affect the initial allocation of a memory zone
if memory is resized, the flags in the original allocation are used, and the read, write, and exec flags are ignored

bit 4 (realloc_exact):
0: returned memory could be longer then specified {len}
1: returned memory is exactly as long as {len}
specifieng this option could lead to wasted physical memory

return value:
mem:
pointer to start of memory, or 0 if all memory was freed or there was an error
len:
length of memory allocated in pages, this is guarenteed to ba at least {len} pages long,
but it could be longer than specified, unless the realloc_exact option is specified
err:
0: success
1: failure


12: fn mmio_map (phys_addr: usize, n: usize) -> usize
maps n pages starting at physical address phys_addr into the calling process's address space
only superuser or iopriv processes can call mmap

return value:
0: mmap was called with insufficent privallages or the requested memory zone is not memory mapped io
any other value: virtual address of mapped region


13: fn mmio_unmap (virt_addr: usize)
unmaps memory previously mapped by mmap
only superuser or iopriv processes can call munmap


14: fn port_map (port: usize) -> usize
allows the process to use port {port}
only superuser or iopriv processes can call munmap

return value:
0: success
1: failure


15: fn port_unmap (port: usize)
the process can no longer use port {port}
only superuser or iopriv processes can call munmap


16: fn salloc (pages: usize) -> usize
allocate shared memory to be shared with msg


17: fn sdealloc (addr: usize)
free shared memory allocated by salloc or recieved by another process
removes the shared memory from current address space, and once all processes that had it
free it, shared memory is deallocated from physical memory


18: fn smem_size (addr: usize) -> usize
returns the size of shared memory at {addr} in pages
returns 0 if there is no shared memory at {addr}


19: mprotect (addr: usize) -> usize
sets the read, write, and execute permissions on a chunk of memory
mprotect cannot be called on shared memory after it has already been shared

options:
bit 0 (read):
allows reading of memory

bit 1 (write):
allows writing to memory

bit 2 (exec):
allows executing instrcutions from memory

return valus:
0: success
1: failure


20: fn reg (domain: usize, rip: usize, | gid: usize) -> usize
register function at instrcution pointer {rip} to handle messages with domain {domain}

options:
bit 0 (reg_block):
0: will spawn a new thread to handle the message
1: will block the current thread and switch to a temporary stack to handle the message
use msg_return to leave this temporary stack

bit 1 (reg_default):
0: reg registers function only for specified domain
1: reg registers function to respond to all domains that don't have an individual function registered to handle them

bit 2 (reg_public):
TODO: explain application modules and trees better
0: private, domain cannot be messaged from an application not in the same module in the application tree
1: public, domain can be messaged from outside the application module, assuming parent application modules are public

bit 3 (reg_group):
0: ignore gid argument
1: applications must be member of group specified by {gid} to message this domain
repated calls with {rip} == 0  and reg_group bit set will allow multiple groups to access this domain

return value:
0: success
1: failure

21: fn msg (eid: *const c_char | pid: usize, domain: usize, a1: usize, a2: usize, a3: usize, a4: usize, a5: usize, a6: usize, a7: usize, a8: usize) -> usize
send a message to another process

options:
bit 0 (msg_pid):
0: send message to all processes with executable id specified in arg
1: send message to process with pid

bit 1 (msg_block):
0: do not wait for reply from other process
if the other process replies, the handler registered for the reply domain will be called
1: block until other process replies
if the other process replies, the data will be put in this processes registers

bit 4-7 (smem_transfer_mask):
transfers shared memory pointed to by a certain register to other process
the recieving process has the memory mapped in their address space, and recieves a pointer to the memory in the respective register
the calling process also recieves the size of the shared memory in the next register
this means that the argument adjacent to the sending process is not sent
bit 4 set: transfers a1
bit 5 set: transfers a3
bit 6 set: transfers a5
bit 7 set: transfers a7

return value:
0: success
1: no process with eid or pid exists


22: fn msg_return ()
returns off the message stack, and back to the regular stack, and restores all original registers
causes any other threads waiting for a reply to unblock
