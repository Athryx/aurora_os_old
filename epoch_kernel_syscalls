TODO:
more descriptive error values
error values are written in kernel, just not described well heare
slightly more consistant names

decide if vfs should go in kernel or not
if it does, can probably remove the info syscall and just use a proc like filesystem
also decide if files should be like unix or not (thinking no)

pledge like syscall

syscall to get groups that pid is part of

figure out how user permissions would work


syscall abi:
rax[0-31]: syscall number
rax[32-63]: syscall options
rbx: arg 1, return 1
rcx: not saved
rdx: arg 2, return 2
rbp: saved
rsp: saved
rsi: arg 3, return 3
rdi: arg 4, return 4
r8: arg 5, return 5
r9: arg 6, return 6
r10: not saved
r11: not saved
r12: arg 7, return 7
r13: arg 8, return 8
r14: arg 9, return 9
r15: arg 10, return 10

all args are saved if they are not used by a particular syscall to return a value

the kernel uses a similar abi to call message handlers
message handler abi:
rax: flags
rbx: sender pid
rcx: unused
rdx: cid
rbp: unused
rsp: unused
rsi: arg 1
rdi: arg 2
r8: arg 3
r9: arg 4
r10: unused
r11: unused
r12: arg 5
r13: arg 6
r14: arg 7
r15: arg 8

more details about this abi under msg syscall


0: fn info ()


// TODO: specify ProcStartData
1: fn spawn (addr: usize, len: usize, psdata: *const ProcStartData) -> (err: SysErr, pid: usize)
spawns a new process
{addr} points to the start of the memory containing the elf executable to be loaded, {len} is the length of the elf executable in bytes
{psdata} contains additional data for the process, and the information in it will be mapped into the new process' memory
the exact data in the ProcStartData structure is TBD, but it will likely have things like command line arguments, stdio smid, uid, etc.
spawn can only be called by a superuser process

return value:
err:
syserr code
pid:
pid of new process


2: fn thread_new (rip: usize) -> (err: SysErr, tid: usize)
creates a new thread and returns its id
the thread function should not return, it should call thread_block with destroy in order to terminate itself

return value:
err:
syserr code
tid:
thread id


3: fn thread_block (reason: usize, | nsec: usize | thread_id: usize)
blocks the calling thread with reason {reason}

reason:
0: yield, sets thread to running state and switches to another thread, if available
if no threads other than the idle thread are ready to run, the current thread will continue to run
1: destroy, switches to another thread and terminates the current thread
if another thread is waiting on this thread for a message reply, than that thread is unblocked
2: sleep, will sleep until {nsec} nanoseconds after boot
3: join, will block until thread with id {thread_id} terminates
any other number will do nothing


5: fn exit (code: usize)
terminates process with exit code {code}


6: fn futex_block (addr: usize)
bloocks the thread until woken by another thread via futex_unblock


7: fn futex_unblock (addr: usize, n: usize) -> usize
unblocks {n} threads waiting on addr and returns how many threads were unblocked
if addr is shared memory, this can also unblock threads in other processess that are waiting
on the same value, with a different virtual address


8: fn futex_move (addr_old: usize, addr_new: usize, n: usize) -> usize
moves {n} threads waiting on {addr_old} to start waiting on {addr_new} and returns how many threads were moved
it is not allowed to move a futex from an address within a shared memory zone to an address in a different shared
memory zone or into a non shared memory zone


9: set_proc_properties
// I don't know if this will stay


10: set_thread_properties


11: fn realloc (mem: usize, len: usize, at_addr: usize) -> (err: SysErr, mem: usize, len: usize)
allocates, rellocates, or frees memory pointed to by mem

if {mem} == 0:
	allocates {len} pages, returns pointer on succes or 0 on failure
	returns 0 if {len} == 0
if {mem} != 0 and {len} == 0:
	frees pages pointed to by {mem} and returns 1 on success or 0 on failure
if {mem} != 0 and {len} != 0:
	reallocates pages to have len {len} and returns pointer on success or 0 on failure
	if it fails, the original pages will still be allocated and must be freed later

if {at_addr} == 0, realloc will pick a suitable virtual address to allocae the memory at

if {at_addr} != 0, realloc will ensure that the allocated memory starts at address {at_addr}
if it cannot fit the memory at this address, it will fail
note: if realloc is allocing at a certain addrss, it may still fail even if there is enough space for {len} pages
this is because realloc may try to map more memory in the virtual address soace than specified by {len}
to ensure this doesn't happen, set the optsion realloc_exact

realloc will never allocate memory at virtual address 0

options:
bit 0 (read):
allows reading of memory

bit 1 (write):
allows writing to memory

bit 2 (exec):
allows executing instrcutions from memory

On x86, a page will always be readable, even if read bit is set to 0,
unless wrtie and exec are also set to 0, in which case realloc will just reserve
the virtual memory, and not actually allocate anything

read, write, and exec flags only affect the initial allocation of a memory zone
if memory is resized, the flags in the original allocation are used, and the read, write, and exec flags are ignored

bit 4 (realloc_exact):
0: returned memory could be longer then specified {len}
1: returned memory is exactly as long as {len}
specifieng this option could lead to wasted physical memory

return value:
err:
syserr code
mem:
pointer to start of memory, or 0 if all memory was freed or there was an error
len:
length of memory allocated in pages, this is guarenteed to ba at least {len} pages long,
but it could be longer than specified, unless the realloc_exact option is specified


12: fn mmio_map (phys_addr: usize, n: usize) -> (err: SysErr, addr: usize)
maps n pages starting at physical address phys_addr into the calling process's address space
only superuser or iopriv processes can call mmap

return value:
err: syserr code
addr: virtual address of mapped region


13: fn mmio_unmap (virt_addr: usize)
unmaps memory previously mapped by mmap
only superuser or iopriv processes can call munmap


14: fn port_map (port: usize) -> SysErr
allows the process to use port {port}
only superuser or iopriv processes can call munmap

return value:
syserr code


15: fn port_unmap (port: usize)
the process can no longer use port {port}
only superuser or iopriv processes can call munmap


16: fn salloc (pages: usize) -> (err: SysErr, smid: usize)
allocate shared memory to be shared with msg
returns the shared memory id (smid) that can be mapped with smap or shared with msg
NOTE: smids are process local, so they must be shared with msg, and they cannot be shared using other shared memory

options:
bit 0 (read):
allows reading of shared memory

bit 1 (write):
allows writing to shared memory

bit 2 (exec):
allows executing instrcutions from shared memory

return value:
err: syserr code
smid: shared memory id


17: fn sdealloc (smid: usize)
free shared memory allocated by salloc or recieved by another process
unmaps the shared memory if it has not yet been unmapped, and it invalidates {smid}
once all processess that had the shared memory free it, the shared memory is deallocated from physical memory


18: fn smap (smid: usize) -> (err: SysErr, addr: usize, pages: usize)
mappes the shared memory with id {smid}

return value:
err: syserr code
addr: address of shared memory
pages: length of shared memory region in pages


19: fn sunmap (smid: usize)
unmaps the shared memory with id {smid}


20: fn smem_size (smid: usize) -> usize
returns the size of shared memory at {smid} in pages
returns 0 if there is no shared memory with id {smid}


21: fn mprotect (addr: usize) -> usize
sets the read, write, and execute permissions on a chunk of memory
mprotect cannot be called on shared memory

options:
bit 0 (read):
allows reading of memory

bit 1 (write):
allows writing to memory

bit 2 (exec):
allows executing instrcutions from memory

return valus:
0: success
1: failure


22: fn reg (domain: usize, rip: usize, | gid: usize) -> SysErr
register function at instrcution pointer {rip} to handle messages with domain {domain}

options:
bit 0 (reg_block):
0: will spawn a new thread to handle the message
1: will block the current thread and switch to a new stack
can exit this stack and restore state by calling msg_return

bit 1 (reg_default):
0: reg registers function only for specified domain
1: reg registers function to respond to all domains that don't have an individual function registered to handle them

bit 2 (reg_global):
0: local, registers handler to respond to messages sent by pid
1: global, registers handler to respond to messages sent by executable name

bit 3 (reg_public):
0: private, processes can only message this domain when replying to a connection which was listening asynchronously
1: public, and process can message this domain

bit 4 (reg_remove):
0: reg behaves normally
1: reg removes the registered handler if any are registered

bit 5 (reg_group):
0: ignore gid argument
1: applications must be member of group specified by {gid} to message this domain
repated calls with {rip} == 0 and reg_group bit set will allow multiple groups to access this domain

return value:
syserr code:
InvlPriv:
could not register handler for domain under executable name because another process already registered a handler


23: fn connect (exec_name: *const char | pid: usize, exec_name_len: usize |, domain: usize) -> (err: SysErr, cid: usize)
open a connection with another process (can not open connection to self)

options:
bit 0 (connect_pid):
0: open connection with domain handler registered for {exec_name}
1: open connection with domain handler registered for process with pid {pid}

return value:
cid: connection id
err: syserr code


24: fn disconnect (cid: usize)
close connection with cid {cid}


25: conn_info (cid: usize)


26: fn msg (cid: usize, a1: usize, a2: usize, a3: usize, a4: usize, a5: usize, a6: usize, a7: usize, a8: usize) -> SysErr
send a message to another process (process cannot message itself)
note: this syscall returns using the message handler api
the first msg sent will call the DomainHandler registered at the time of calling connect
if the other process asynchronously awaits reply, subsequent replies will use the processess locally registered handler at the time of calling msg

options:
bit 1 (msg_block):
0: do not wait for reply from other process
if the other process replies, the handler registered for the reply domain will be called
1: block until other process replies
if the other process replies, the data will be put in this processes registers

bit 8-15 (smem_transfer_mask):
transfers shared memory references by smid in a certain register to other process
the recieving process recieves an smid that can be mapped with smap
bit 8 set: transfers a1
bit 9 set: transfers a2
bit 10 set: transfers a3
bit 11 set: transfers a4
bit 12 set: transfers a5
bit 13 set: transfers a6
bit 14 set: transfers a7
bit 15 set: transfers a8

return value:
this syscall returns using the message handler api if it is called with msg_reply flag set
if it is not called with msg_reply, it will return msg_return_value normaly, wich is a syserr code

message handler abi:
rax: flags
rbx: sender pid
rcx: unused
rdx: domain
rbp: unused
rsp: unused
rsi: arg 1
rdi: arg 2
r8: arg 3
r9: arg 4
r10: unused
r11: unused
r12: arg 5
r13: arg 6
r14: arg 7
r15: arg 8

options:
bits 0-7 (msg_return_value):
syserr code
it is not specified if original registers are preserved

bit 8-15 (smem_transfer_mask):
this bitmask specifies which args contain smids
bit 8 set: arg 1 has smid
bit 9 set: arg 2 has smid
bit 10 set: arg 3 has smid
bit 11 set: arg 4 has smid
bit 12 set: arg 5 has smid
bit 13 set: arg 6 has smid
bit 14 set: arg 7 has smid
bit 15 set: arg 8 has smid


27: fn msg_return () -> SysErr
returns of msg stack


28: fn print_debug (a1: usize, a2: usize, a3: usize, a4: usize, a5: usize, a6: usize, a7: usize, a8: usize, a9: usize, a10: usize)
prints the characters specified in the arguments to the debug console
this syscall is only for debugging until I write a terminal emulator
each argument is a combination of 8 bit characters to print to the screen
the order the characters are printed is as follows:
lower number arguments are printed before higher numbered arguments (a1 before a2 before a3, etc)
least significant bytes in each argument are printed first (a1 bits 0-7, a1 bits 8-15, a1 bits 16-23, etc)

options:
bits 0-7 (debug_print_num):
specifies the number of characters to print (max 80 on 64 bit system)
