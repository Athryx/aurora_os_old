TODO:
more descriptive error values
error values are written in kernel, just not described well heare
slightly more consistant names

specify layout of global information table

specify atomicity of syscalls

specify all the privalidge flags

write descriptions of all syscalls that don't have a description yet

decide if mprotect is needed

IMPLEMANTATION ISSUES:
io syscalls unimpleted
realloc does not correctly follow all flags


syscall abi:
rax[0-31]: syscall number
rax[32-63]: syscall options
rbx: arg 1, return 1
rcx: not saved
rdx: arg 2, return 2
rbp: saved
rsp: saved
rsi: arg 3, return 3
rdi: arg 4, return 4
r8: arg 5, return 5
r9: arg 6, return 6
r10: not saved
r11: not saved
r12: arg 7, return 7
r13: arg 8, return 8
r14: arg 9, return 9
r15: arg 10, return 10

all args are saved if they are not used by a particular syscall to return a value


syserr codes:
syserr codes that mey be returned by all syscalls:
Ok: operation completed succesfully
OutOfMem: not enough memory available to perform operation


common struct definitions:
struct UserArray<T> {
	data: *const T,
	len: usize,
}
len is number of elements, not bytes
data must be properly aligned for the type it is pointing to

struct UserString {
	data: UserArray<u8>,
}
must point to a valid utf-8 string

struct UserPageArray {
	addr: usize,
	len: usize,
}
addr must be page aligned
len is number of pages

PrivFlags(usize)
a bitmask of syscalls that a process is allowed to make
bit 0-1 (spawn_priv):
0: process is forbidden from calling spawn
1: process can call spawn, but it cannot spawn a process which has privalidges that it itself does not have
2: process can call spawn, and can spawn a process with higher privalidges than itself
bit 2 (priv_any): allows process to set its privalidge to any arbritrary value, instead of only being able to revoke privalidges it already has
bit 3-4 (kill_priv):
0: process is forbidden from calling kill
1: process can call kill, but it cannot use the kill_force option
2: process can call kill, with any option

CapPriv(usize)
a bitmask representing the permissions of a capability
bit 0 (cap_read): allows reading of or sending to the object referenced by this capability
bit 1 (cap_prod): allows proding the object referenced by the capability
bit 2 (cap_write): allows writing to or recieving from the object referenced by this capability
in general, operations that require cap_read read properties without altering the objects state
operations requiring cap_prod may alter internal state, but in a less privalidged and less abritrary way than write
operations requiring cap_write can alter large portions of the objects internal state

CapFlags(usize)
a bitmask representing the various properties of a capability
bit 0-2 (cap_priv): specifies the privalidges of a capability
uses bits 0-2 of the CapPriv type
bit 3-5 (cap_type): specifies what type of object the capability refers to
0: channel
1: futex
2: memory
3: key
4: process
5: mmio memory
6: interrupt
7: port

// Thread id
type tid = usize;

// Event id
type eid = usize;

// Capability id
// when picking an id for a capability, the kernel ensures that the bottom 6 bits match the CapFlags that represent information about the capability
type Cap<T> = usize;
// in the documentation, generic types will be used to denote which functions can accept which types of capabilities
// the following generic traits will also be used:
trait Map {}
impl Map for Mem {}
impl Map for Mmio {}


fn print_debug(a1: usize, a2: usize, a3: usize, a4: usize, a5: usize, a6: usize, a7: usize, a8: usize, a9: usize, a10: usize)
prints the characters specified in the arguments to the debug console
this syscall is only for debugging until I write a terminal emulator
each argument is a combination of 8 bit characters to print to the screen
the order the characters are printed is as follows:
lower number arguments are printed before higher numbered arguments (a1 before a2 before a3, etc)
least significant bytes in each argument are printed first (a1 bits 0-7, a1 bits 8-15, a1 bits 16-23, etc)

options:
bits 0-7 (debug_print_num):
specifies the number of characters to print (max 80 on x86_64)


fn hret()
returns from an asynchronous event handler


fn info_table() -> (err: SysErr, table: Cap<Mem>)
returns a capability to the global information table

return value:
syserr code:

table: a capability to the global information table
the capability has cap_read permissions


fn process_new() -> (err: SysErr, process: Cap<Process>)
creates a new process

options:
bits 0-2 (process_cap_flags): CapPriv representing privalidges of new capability

return value:
syserr code:
InvlPriv: process does not have sufficient privalidges to call this syscall

pocess: capability of new process


fn thread_new(process: Cap<Process>, rip: usize, rsp: usize, r1: usize, r2: usize, r3: usize, r4: usize, r5: usize, r6: usize, r7: usize) -> (err: SysErr, tid: tid)
creates a new thread in {process} and returns its id
the new thread will have its rip and rsp registers set according to the values passed in
7 additional registers can be passed in, and they correspond to certain registers that will be set in the new thread
on x86_64, the registers correspond as follows:
{r1}: rax
{r2}: rbx
{r3}: rcx
{r4}: rdx
{r5}: rdi
{r6}: rsi
{r7}: rbp

all other registers are set to 0

return value:
syserr code:
InvlCap: process capability does not have cap_write permissions

tid:
thread id


// TODO: specify process capability and prune opperations
fn thread_block(reason: usize, | nsec: usize | thread_id: tid) -> SysErr
blocks the calling thread with reason {reason}

reason:
0: yield, sets thread to ready state and switches to another thread, if available
if no threads other than the idle thread are ready to run, the current thread will continue to run
1: destroy, switches to another thread and terminates the current thread
2: sleep, will sleep until {nsec} nanoseconds after boot
3: join, will block until thread with id {thread_id} terminates
4: await, will wait until any pending asynchronous messages are recieved
if there are no pending asynchronous messages, this will do nothing, and the thread will continue to run as normal
any other number will do nothing

return value:
syserr code:
InvlArgs: invalid reason passed to thread_block


fn cap_clone<T>(process: Cap<Process>, cap: Cap<T>) -> (err: SysErr, cap_new: Cap<T>)
clones the capability {cap} into {process} with different privalidges

options:
bit 0-2 (cap_flags): CapPriv representing privalidges of new capability
these privalidges are anded with the privalidges {cap} already has, so clone can only create capabilities with the same or less privalidges as the original

return value:
syserr code:
InvlId: no capability with cid {cap} exists
InvlCap: process capability does not have cap_write permissions

cap_new: cid of new capability


fn cap_move<T>(process: Cap<Process>, cap: Cap<T>) -> (err: SysErr, cap_new: Cap<T>)
makes a new capability with different privalidges in the process {process} referencing the same object, and destroys the old capability

options:
bit 0-2 (cap_flags): CapPriv representing privalidges of new capability
these privalidges are anded with the privalidges {cap} already has, so clone can only create capabilities with the same or less privalidges as the original

return value:
syserr code:
InvlId: no capability with cid {cap} exists
InvlCap: process capability does not have cap_write permissions

cap_new: cid of new capability


fn cap_destroy<T>(process: Cap<Process>, cap: Cap<T>) -> SysErr
destroys the capability {cap} in process {process}
when the object referenced by {cap} has 0 references left, it is freed

return value:
syserr code:
InvlId: no capability with cid {cap} exists
InvlCap: process capability does not have cap_write permissions


fn cap_map<T: Map>(process: Cap<Process>, cap: Cap<T>, at_addr: usize) -> (err: SysErr, addr: usize, len: usize)
maps a capability {cap} that can be mapped into memory into the memory of process {process}
the mapped memory read, write, and execute permissions depend on cap_read, cap_write, and cap_prod permissions respectively
if {at_addr} is not 0, cap_map tries to map the memory starting at {at_addr}, fails if the memory is already occupied, or it is reserved and map_force is not used
cap_map will never map the page starting at addres 0, even if map_force is used

options:
bit 0 (map_force):
when used with map_at, allows mapping memory to reserved memory zones
does nothing if map_at is not used

return value:
syserr code:
InvlPriv: calling process has insuficiant privalidges to call this syscall
InvlId: no mappable capability with cid {cap} exists
InvlOp: the capability is already mapped into this process' address space
InvlVirtAddr: at_addr is non canonical
InvlAlign: at_addr is not page aligned
InvlVirtMem: the value passed in for at_addr causes the mapped memory to overlap with other virtual memory or reserved memory
InvlCap: process capability does not have cap_write permissions

addr: address of mapped memory

len: length of mapped memory in pages


fn cap_unmap<T: Map>(process: Cap<Process>, cap: Cap<T>) -> SysErr
unmaps memory mapped by cmap

return value:
syserr code:
InvlPriv: calling process has insuficiant privalidges to call this syscall
InvlId: no mappable capability with cid {cap} exists
InvlOp: the capability is not mapped into {process} address space


fn mem_new(pages: usize) -> (err: SysErr, cap: Cap<SMem>)
allocate memory at least {pages} big
returns the capability referencing this shared memory

options:
bit 0-2 (smem_cap_flags): CapPriv representing read and write privalidges over this memory

return value:
syserr code:
InvlPriv: does not have privalidge to call this syscall

cap: cid of shared memory


fn event_new(args: usize) -> (err: SysErr, cap: Cap<Event>)
creates a new event
{args} specifies the number of arguments the event accepts, it can be any number from 0-8

options:
bit 0-2 (smem_cap_flags): CapPriv representing the permissions of the returned capability

return value:
syserr code:
InvlArgs: {args} was not a number from 0-8

cap: capability id of futex


fn event_send(event: Cap<Event>, | count: usize, | arg1: usize, | arg2: usize, | arg3: usize, | arg4: usize, | arg5: usize, | arg6: usize, | arg7: usize, | arg8: usize) -> SysErr
sends a {count} messages to an event
ignores all arguments grater than the number of arguments the event takes

options:
bit 0 (event_send_all):
sends event message to all listening threads. If there are no listening threads, does nothing

return value:
syserr code:
InvlId: no event capability with cid {event} exists
InvlCap: {event} capability does not have cap_write permissions


the kernel uses the folowing abi to call event listeners in the following syscalls:
rax: unused
rbx: cid of event capability, if the cap_type bits indicate that the cid is a valid event
if the cid does not reference an event, than it is not a valid cid, and bits 32-63 are set to a syserr code
syserr codes returned in rbx are described in each syscall
rcx: unused
rdx: arg 1
rbp: unused
rsp: unused
rsi: arg 2
rdi: arg 3
r8: arg 4
r9: arg 5
r10: unused
r11: unused
r12: arg 6
r13: arg 7
r14: arg 8
r15: unused


fn event_listen(event: Cap<Event>, timout: | usize) -> CUSTOM
synchronously listens on an event
if the current thread is asynchronously listening on the event, the asynchronous listen will be aborted

options:
bit 1 (event_timeout):
if the thread has not been unblocked by {timeout_nsec} nanoseconds after boot, the thread will be unblocked,
and OkTimeout will be returned

return value:
event listener return abi
syserr code:
InvlId: no event capability with cid {event} exists
InvlCap: {event} capability does not have cap_prod permissions
OkTimeout: timeout exceeded


fn event_nblisten(event: Cap<Event>, timout: | usize) -> CUSTOM
polls an event object to see if it contains an event, returns event if it has event, or returns OkUnreach if it doesn't

return value:
event listener return abi
syserr code:
InvlId: no event capability with cid {event} exists
InvlCap: {event} capability does not have cap_prod permissions
OkUnreach: event object contained no events


fn event_alisten(event: Cap<Event>, handler: usize) -> SysErr
asynchronously listens for an event
calls the handler with the event handler abi when an event is recieved
use the hret syscall to return from the event handler

return value:
syserr code:
InvlId: no event capability with cid {event} exists
InvlCap: {event} capability does not have cap_prod permissions
InvlOp: thread is already asynchronously listening on this event object


fn event_aabort(event: Cap<Event>) -> SysErr
stops asynchronously listening on the event


return value:
syserr code:
InvlId: no event capability with cid {event} exists
InvlCap: {event} capability does not have cap_prod permissions
InvlOp: thread is not already asynchronously listening on this event object


fn key_new() -> (err: SysErr, cap: Cap<Key>)
ceates a new key object
keys are used by userpace servers to identify sessions, and manage permissions
each key is a globally unique integer, and this integer can be obtained with the key_id syscall

return value:
cap: key capability id
key capability returned has cap_read permissions


fn key_id(key: Cap<Key>) -> (err: SysErr, id: usize)
returns the key's id

return value:
syserr code:
InvlId: invalid capability id
InvlCap: key capability does not have cap_read permissions

id: the key's id


15: fn cap_info<T>(cap: Cap<T>) -> SysErr


16: fn port_new(port: u16) -> (err: SysErr, cap: Cap<Port>)
creates a capability referencing a port object on the specified port

return value:
syserr code:
InvlPriv: does not have privalidge to call this syscall
InvlArgs: port passed to port_new is reserved by the kernel
InvlOp: another capability referencing this port already exists

cap: capability referencing the port


17: fn port_map(cap: Cap<Port>) -> SysErr
allows the process to use the port referenced by {cap}

return value:
syserr code:
InvlPriv: does not have privalidge to call this syscall
InvlId: no capability with cid {cap} exists, or capability is not a port capability
InvlOp: process had already mapped port


18: fn port_unmap(cap: Cap<Port>) -> SysErr
the process can no longer use the port referenced by {cap}

return value:
syserr code:
InvlPriv: does not have privalidge to call this syscall
InvlId: no capability with cid {cap} exists, or capability is not a port capability
InvlOp: process had not yet mapped port


19: fn mmio_new(phys_addr: usize, n: usize) -> (err: SysErr, cap: Cap<Mmio>)
creates a new capability that references memory mapped io

option:
bit 0-1 (mmio_cap_flags): CapPriv representing read and write privalidges over this memory

return value:
syserr code:
InvlPriv: does not have privalidge to call this syscall
InvlArgs: memory reagion passed to mmio_new is not a valid mmio region
InvlOp: another capability referencing this memory already exists

cap: cid of memory mapped io


20: fn int_new(int: usize) -> (err: SysErr, cap: Cap<Interrupt>)


21: fn int_wait(cap: Cap<Interrupt>) -> (err: SysErr, n: usize)


22: fn int_eoi(cap: Cap<Interrupt>) -> SysErr


fn channel_new(msg_size: usize) -> (err: SysErr, cap: Cap<Channel>)
creates a new channel object that sends messages up to {msg_size} words
{msg_size} can either be 0, in which case no messages are sent, and channel can be used as a synchronization primitive,
or it has to be at least 4

options:
bit 0-2 (smem_cap_flags): CapPriv representing the permissions of the returned capability
bit 3 (chan_sc_resist): resist side channel attacks
if set, all non blocking calls will return SysErr::Obscured

return value:
syserr code:
InvlPriv: does not have privalidge to call this syscall
InvlArgs: {msg_size} was either 1, 2, or 3, which is not allowed

cap: cid of channel


the format of the message buffer sent by the following syscalls is described bellow
word means the size of a word (64 bits on x64, not 16 bits)
word 1: length of the message, in words, including this field and all other header fields
when the message is sent, the kernel will clamp the word to ensure it is less than the maximum message length for the channel it is being sent on, and greater than the position of the last sent capability
word 2: flags
bit 0 (reply):
if this bit is set, a capability to a channel object is sent in the reply object word, and the reciever should reply with reply_recv to this channel
if this bit is not set, the reply word will be zeroed
bit 32-63 (cap_count):
the number of capabilities to send / the number that were sent
the kernel will clamp this value if it exceeds the message buffer length
if any capability does not exist, the kernel will ignore that value, and decrement the length by 1
word 3: reply
a capability to a channel object for server to reply to, zeroed if unused

after these words, there will be all the capabilities
after the capabilities, there will be all the data words
the data words continue to the end of the message


fn channel_send(channel: Cap<Channel>, msg_buff: Cap<Mem>) -> SysErr
sends a message, blocks until someone recieves the message
{msg_buff} specifies the message buffer to send the message from

return value:
syserr code:
InvlId: no capability with id {channel} or id {msg_buff} exists
InvlArgs: {msg_buff} does not reference memory that is big enough to hold a message
InvlCap: {channel} does not have cap_prod privalidges, or {msg_buf} does not have cap_read privalidges


fn channel_recv(channel: Cap<Channel>, msg_buff: Cap<Mem>) -> SysErr
recieves a message, blocks until someone sends a message
{msg_buff} specifies the message buffer to recieve the message into

return value:
syserr code:
InvlId: no capability with id {channel} or id {msg_buff} exists
InvlArgs: {msg_buff} does not reference memory that is big enough to hold a message
InvlCap: {channel} does not have cap_prod privalidges, or {msg_buf} does not have cap_write privalidges


fn channel_nbsend(channel: Cap<Channel>, msg_buff: Cap<Mem>) -> SysErr
sends a message if someone is waiting to recieve a message, otherwise return
{msg_buff} specifies the message buffer to send the message from

return value:
syserr code:
InvlId: no capability with id {channel} or id {msg_buff} exists
InvlArgs: {msg_buff} does not reference memory that is big enough to hold a message
InvlCap: {channel} does not have cap_prod privalidges, or {msg_buf} does not have cap_read privalidges
Obscured: {channel} has conn_sc_resist set
OkUnreach: nobody was waiting to recieve a message


fn channel_nbrecv(channel: Cap<Channel>, msg_buff: Cap<Mem>) -> SysErr
recieves a message if someone is waiting to send a message, otherwise return
{msg_buff} specifies the message buffer to recieve the message into

return value:
syserr code:
InvlId: no capability with id {channel} or id {msg_buff} exists
InvlArgs: {msg_buff} does not reference memory that is big enough to hold a message
InvlCap: {channel} does not have cap_prod privalidges, or {msg_buf} does not have cap_write privalidges
Obscured: {channel} has conn_sc_resist set
OkUnreach: nobody was waiting to recieve a message


36: fn channel_asend(cap: Cap<Channel>, msg_buff: usize, func: usize) -> (err: SysErr, id: aid)
asynchronously send a message
{msg_buff} specifies the message buffer to send the message from
{func} specifies the callback to call once the message is sent

return value:
syserr code:
InvlId: no capability with id {cap} exists
InvlOp: {cap} does not reference an object that implements Communicate
InvlAddr: {msg_buff} does not point to a valid message buffer
InvlPriv: pocess does not have sufficient privalidges to call asend
InvlCap: capability does not have send privalidges

id: the aid of the asynchronous action


37: fn channel_arecv(cap: Cap<Channel>, msg_buff: usize, func: usize) -> (err: SysErr, id: aid)
asynchronously recieve a message
{msg_buff} specifies the message buffer to recieve the message into
{func} specifies the callback to call once the message is recieved

return value:
syserr code:
InvlId: no capability with id {cap} exists
InvlOp: {cap} does not reference an object that implements Communicate
InvlAddr: {msg_buff} does not point to a valid message buffer
InvlPriv: pocess does not have sufficient privalidges to call arecv
InvlCap: capability does not have recieve privalidges

id: the aid of the asynchronous action


38: fn channel_reply_recv(reply_cap: Cap<Channel>, recv_cap: Cap<Channel>, msg_buff: usize) -> SysErr
reply to a channel, destroy it, than listen to another channel
reply_recv first does a nbsend to {reply_cap}, and will then destroy the capability {reply_cap}
reply_recv then calls recv on {recv_cap}
{msg_buff} specifies the message buffer to reply with and recieve into

return value:
syserr code:
InvlId: no capability with id {cap} exists
InvlOp: {cap} does not reference a reply
InvlAddr: {msg_buff} does not point to a valid message buffer
InvlPriv: pocess does not have sufficient privalidges to call reply_recv
InvlCap: reply capability does not have send privalidges, or recieve capability not have recieve privalidges


39: fn channel_call(cap: Cap<Channel>, msg_buff: usize) -> SysErr
call a channel
call first creates a reply channel, and then performs send on {cap}
call will send the reply channel capability in the reply slot in the message
after the message is recieved, call than performs a recv on the reply capability, and will wait for a responce from the server
after the message is recieved, call destroys the reply channel capability
{msg_buff} specifies the message buffer to send from and recieve into

return value:
syserr code:
InvlId: no capability with id {cap} exists
InvlOp: {cap} does not reference a channel
InvlAddr: {msg_buff} does not point to a valid message buffer
InvlPriv: pocess does not have sufficient privalidges to call call
InvlCap: channel capability does not have send privalidges


40: fn channel_acall(cap: Cap<Channel>, msg_buff: usize, func: usize) -> (err: SysErr, id: aid)
asynchronously call a channel
acall first creates a reply channel, and then performs asend on {cap}
acall will send the reply channel capability in the reply slot in the message
after the message is recieved, acall than performs an arecv on the reply capability, and will wait for a responce from the server
after the message is recieved, acall destroys the reply channel capability, and calls the callback funnction specified in {func} and passes in the {msg_buff} pointer
{msg_buff} specifies the message buffer to send from and recieve into

return value:
syserr code:
InvlId: no capability with id {cap} exists
InvlOp: {cap} does not reference a channel
InvlAddr: {msg_buff} does not point to a valid message buffer
InvlPriv: pocess does not have sufficient privalidges to call acall
InvlCap: channel capability does not have send privalidges

id: the aid of the asynchronous action


41: fn aabort(id: aid) -> SysErr
aborts the asynchronous action specified by {id}

return value:
syserr code:
InvlId: no no asynchronous action with aid {id} exists
this could be because an asynchrounous action with that id never existed, or because the action already completed
